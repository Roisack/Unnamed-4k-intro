const char* perlinNoise_vs =
"varying vec2 tex;"
"varying vec4 vc;"
"uniform float time;"
"void main()"
"{"
"tex = gl_MultiTexCoord0.xy;"
"gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;"
"vc = gl_Color;"
"}";
const char* perlinNoise_fs =
"uniform sampler2D base;"
"varying vec2 tex;"
"uniform float time;"
"varying vec4 vc;"
"int octaves = 9;"
"float amplitude = 0.45;"
"float persistence = 0.85;"
"float inter(float x0, float x1, float alpha)"
"{"
"return (x0 * (1.0 - alpha) + alpha * x1);"
"}"
"float noise2(vec2 ii, int octave)" 
"{"
"float ou = 0.0f;"
"float i = ii.s;"
"float j = ii.t;"
"int aa = int(ii.s * 1024);"
"int jres = int(ii.t * 1024);"
"int sp = 1 << octave;"
"float freq = 1.0f / sp;"
"int si0 = (aa / sp) * sp;"
"int si1 = (si0 + sp) % 1024;"
"float horiz = (aa - si0) * freq;"
"int sj0 = (jres / sp) * sp;"
"int sj1 = int(sj0 + sp) % 1024;"
"float vert = (jres - sj0) * freq;"
"float coord1 = float(si0) / 1024;"
"float coord2 = float(si1) / 1024;"
"float coord3 = float(sj0) / 1024;"
"float coord4 = float(sj1) / 1024;"
"float top = inter(texture2D(base, vec2(coord1,coord3)).r, texture2D(base, vec2(coord2, coord3)).r, horiz);"
"float bottom = inter(texture2D(base, vec2(coord1, coord4)).r, texture2D(base, vec2(coord2, coord4)).r, horiz);"
"ou = inter(top, bottom, vert);"
"return ou;"
"}"
"void main()"
"{"
"float noiseOctaves[20];"
"float totalAmplitude = 0.0f;"
"float n;"
"float perlinNoise = 0.0f;"
"for (int i = 0; i < octaves && i < 20; i++)"
"noiseOctaves[i] = noise2(tex.st, i);"
"if (time > 2580) {"
"for (int i = octaves-1; i >= 0; i--)"
"{"
"amplitude *= persistence;"
"totalAmplitude += amplitude;"
"perlinNoise += (noiseOctaves[i] * amplitude * abs(sin(tex.s*time/100)) - abs(cos(tex.t*time/20)));"
"}"
"} else {"
"for (int i = octaves-1; i >= 0; i--)"
"{"
"amplitude *= persistence;"
"totalAmplitude += amplitude;"
"perlinNoise += (noiseOctaves[i] * amplitude);"
"}"
"}"
"vec4 col = perlinNoise;"
"gl_FragColor = col;"
"}";
